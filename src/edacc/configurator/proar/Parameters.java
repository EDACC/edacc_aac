package edacc.configurator.proar;

import java.util.HashMap;

import edacc.api.costfunctions.CostFunction;

public class Parameters {
	String hostname = "", user = "", password = "", database = "";
	int idExperiment = 0;
	int port = 3306;
	int jobCPUTimeLimit = 13;
	long seed = System.currentTimeMillis();
	String algorithm = "ROAR";
	String costFunc = "par10";
	boolean minimize = true;
	int parcoursExpansion = 1;
	int maxParcoursExpansionFactor = 5;
	int initialDefaultParcoursLength = 10;
	int minCPUCount = 0;
	int maxCPUCount = 0;
	int minRuns = 0;
	float maxTuningTime = -1;
	String racing = "Default";
	StatisticFunction statistics;
	HashMap<String, String> configuratorMethodParams = new HashMap<String, String>();
	
	public void setStatistics(CostFunction costFunc, boolean minimize) {
		this.statistics = new StatisticFunction(costFunc, minimize);
	}
	
	/**
	 * Returns the statistic function to be used. 
	 * @return statistic function
	 */
	public StatisticFunction getStatistics() {
		return statistics;
	}
	
	public HashMap<String, String> getConfiguratorMethodParameters() {
		return configuratorMethodParams;
	}
	
	/**
	 * The number of jobs that a configuration gets when its parcours is
	 * expanded
	 * @return
	 */
	public int getParcoursExpansion() {
		return parcoursExpansion;
	}
	
	/**
	 * maximum allowed tuning time = sum over all jobs in seconds 
	 * @return
	 */
	public float getMaxTuningTime() {
		return maxTuningTime;
	}
	
	/**
	 * The maximum length of the parcours that will be generated by the
	 * configurator as a factor of the number of instances; i.e.: if the
	 * maxParcoursExpansionFactor = 10 and we have 250 instances in the
	 * configuration experiment then the maximum length of the parcours will be
	 * 2500.
	 * @return
	 */
	public int getMaxParcoursExpansionFactor() {
		return maxParcoursExpansionFactor;
	}
	
	public int getInitialDefaultParcoursLength() {
		return initialDefaultParcoursLength;
	}
	
	public int getMinCPUCount() {
		return minCPUCount;
	}
	
	public int getMaxCPUCount() {
		return maxCPUCount;
	}
	
	/**
	 * minimum number of runs for a new solver configuration
	 * @return
	 */
	public int getMinRuns() {
		return minRuns;
	}
	
	public int getIdExperiment() {
		return idExperiment;
	}
	
	public int getJobCPUTimeLimit() {
		return jobCPUTimeLimit;
	}
	
	public String toString() {
		String paramsForAlgo = "";
		for (String key : configuratorMethodParams.keySet()) {
			paramsForAlgo += "(" + key + "," + configuratorMethodParams.get(key) + ") ";
		}
		return "c Host: " + user + ":xxxxx" + "@" + hostname + ":" + port + "/" + database + "\n" 
		+ "c Experiment Id: " + idExperiment + "\n" 
		+ "c Algorithm: " + algorithm + "\n" 
		+ "c Racing Schema: " + racing + "\n" 
		+ "c Optimizing statistic: " + costFunc + "\n" 
		+ "c towards: " + (minimize ? "mimisation" : "maximisation") + "\n" 
		+ "c Parcours expansion pro level: " + parcoursExpansion + "\n" 
		+ "c Maximum parcours expansion factor: " + maxParcoursExpansionFactor + "\n" 
		+ "c Initial Parcours for first config: " + initialDefaultParcoursLength + "\n" 
		+ "c Minimum number of runs for a new solver config: " + minRuns + "\n"
		+ "c CPU time limit: " + jobCPUTimeLimit + "\n" 
		+ "c Maximum tuning time: " + (maxTuningTime == -1 ? "unlimited" : maxTuningTime) + "\n" 
		+ "c Seed: " + seed + "\n" + "c Parameters for algorithm: " + paramsForAlgo + "\n";
	}
}
